diff --git a/aesara/link/c/cmodule.py b/aesara/link/c/cmodule.py
index ecae473f9..139fed63e 100644
--- a/aesara/link/c/cmodule.py
+++ b/aesara/link/c/cmodule.py
@@ -5,6 +5,7 @@ Generate and compile C modules for Python.
 import atexit
 import distutils.sysconfig
 import importlib
+import io
 import logging
 import os
 import pickle
@@ -19,6 +20,7 @@ import tempfile
 import textwrap
 import time
 import warnings
+from contextlib import contextmanager, redirect_stderr, redirect_stdout
 from io import BytesIO, StringIO
 from typing import Callable, Dict, List, Optional, Set, Tuple, cast
 
@@ -2715,11 +2717,43 @@ def default_blas_ldflags():
         # isort: off
         import numpy.distutils.system_info  # noqa
 
-        # We need to catch warnings as in some cases NumPy print
+        # We need to catch warnings as in some cases NumPy prints
         # stuff that we don't want the user to see.
-        # I'm not able to remove all printed stuff
-        with warnings.catch_warnings(record=True):
-            numpy.distutils.system_info.system_info.verbosity = 0
+        numpy.distutils.system_info.system_info.verbosity = 0  # side-effect
+
+        class NumpyCompatibleStdoutStringIO(io.StringIO):
+            """Temporarily replaces sys.stdout to capture Numpy output.
+
+            Numpy expects the .encoding attribute to be a string, but for io.StringIO
+            it is set to None and not writable, hence the need for this subclass.
+
+            (See forward_bytes_to_stdout in numpy.distutils.exec_command.)
+            """
+
+            encoding = sys.stdout.encoding
+
+        @contextmanager
+        def filter_numpy_missing_executable_warnings():
+            executables = ["g77", "f77", "ifort", "ifl", "f90", "DF", "efl"]
+            with warnings.catch_warnings(record=True):
+                stdout_sio, stderr_sio = NumpyCompatibleStdoutStringIO(), io.StringIO()
+                with redirect_stdout(stdout_sio), redirect_stderr(stderr_sio):
+                    # Body of "with" block executes here:
+                    yield
+                # In case there are messages printed to both stdout and stderr,
+                # they may be incorrectly interspersed. But in the normal case
+                # there should be no output to either, so this should not pose
+                # a problem.
+                for sio, file in ((stdout_sio, sys.stdout), (stderr_sio, sys.stderr)):
+                    lines = sio.getvalue().splitlines()
+                    for line in lines:
+                        if all(
+                            f"Could not locate executable {exe}" not in line
+                            for exe in executables
+                        ):
+                            print(line, file=file)
+
+        with filter_numpy_missing_executable_warnings():
             blas_info = numpy.distutils.system_info.get_info("blas_opt")
 
         # If we are in a EPD installation, mkl is available
